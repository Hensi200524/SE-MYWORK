===============================module-4: INTERODUCTION TO DBMS==================================
LAB 1:

1.create a database :
	CREATE DATABASE school_db;

2.create a table :
	CREATE TABLE students (student_id int PRIMARY KEY AUTO_INCREMENT, student_name varchar(50), age int(50), class varchar(100), address text)

LAB 2:

1.insert 5 records:
INSERT into students(student_name,age,class,address,teacher_id) VALUES('Krishna',24,'tybcom','Morbi');
INSERT into students(student_name,age,class,address,teacher_id) VALUES('Hensi',21,'tybca','Rajkot');
INSERT into students(student_name,age,class,address,teacher_id) VALUES('Mahek',17,'11th','Jamnagar');
INSERT into students(student_name,age,class,address,teacher_id) VALUES('Jagruti',15,'9th','Botad');
INSERT into students(student_name,age,class,address,teacher_id) VALUES('Bhavisha',20,'fybba','Jetpur');

2.retrieve all records using the SELECT statement.
SELECT * FROM students

===============================================================================================

2)SQL Syntax:-

LAB 1:

1: retrieve specific columns (student_name and age) from the students table.
SELECT student_name,age FROM students

LAB 2:

2: retrieve all students whose age is greater than 10.
SELECT * FROM students WHERE age>18

===============================================================================================

3) SQL Constraints:- 

LAB 1:

1:Create a table teachers :
CREATE TABLE teachers(teacher_id int Primary Key AUTO_INCREMENT,teacher_name varchar(100) NOT NULL, 
 subject varchar(200) NOT NULL, email varchar(100) UNIQUE)

LAB 2:

2:FOREIGN KEY constraint to relate the teacher_id from the teachers table with the students table:

1.ALTER TABLE students add teacher_id int;

2.INSERT into students(teacher_id) VALUES (1),(2),(3),(4),(5)

3.UPDATE students set teacher_id =1 WHERE student_id = 1;
UPDATE students set teacher_id =2 WHERE student_id = 2;
UPDATE students set teacher_id =3 WHERE student_id = 3;
UPDATE students set teacher_id =4 WHERE student_id = 4;
UPDATE students set teacher_id =5 WHERE student_id = 5;

4.INSERT INTO teachers(teacher_name, subject, email)
VALUES ('Kiran Mehta', 'Science', 'kiran@example.com');

5.ALTER TABLE `students` ADD `teacher_id` INT NOT NULL AFTER `address`, ADD INDEX (`teacher_id`);

===============================================================================================

4)Main SQL Commands and Sub-commands (DDL):

LAB 1:

1: Create a table courses with columns: course_id, course_name, and course_credits. Set the course_id as the primary key.:
CREATE TABLE courses(course_id INT PRIMARY KEY AUTO_INCREMENT, course_name VARCHAR(50), course_credits varchar(100))

LAB 2:

2: Use the CREATE command to create a database university_db.:
CREATE DATABASE university_db

===============================================================================================

5)ALTER Command:

LAB 1:

1:Modify the courses table by adding a column course_duration using the ALTER command.:
ALTER table courses add course_duration varchar(50)

LAB 2:

2:Drop the course_credits column from the courses table.
ALTER TABLE courses DROP COLUMN course_credits

===============================================================================================

6)DROP Command:

LAB 1:

1.: Drop the teachers table from the school_db database:
DROP TABLE teachers

LAB 2:

2.: Drop the students table from the school_db database and verify that the table has been removed.
DROP TABLE students

===============================================================================================

7)Data Manipulation Language (DML):

LAB 1:

1.Insert three records into the courses table using the INSERT command:
insert INTO courses(course_id,course_name,course_duration) VALUES ('101','DATABASE MANAGEMENT','3 MONTHS');
insert INTO courses(course_id,course_name,course_duration) VALUES ('102','WEB DEVLOPMENT','5 MONTHS');
insert INTO courses(course_id,course_name,course_duration) VALUES ('103','PYTHON PROGRAMMING','2 MONTHS');

LAB 2:

2: Update the course duration of a specific course using the UPDATE command.:
UPDATE courses SET course_duration = '9 MONTHS' WHERE course_id = 104;

LAB 3:

3: Delete a course with a specific course_id from the courses table using the DELETE command.:
DELETE FROM courses WHERE course_id = 104

===============================================================================================

8)Data Query Language (DQL):

LAB 1:

1: Retrieve all courses from the courses table using the SELECT statement:
SELECT * FROM `courses`

LAB 2:

2: Sort the courses based on course_duration in descending order using ORDER BY:
SELECT * FROM `courses` ORDER BY course_duration DESC

LAB 3:

3: Limit the results of the SELECT query to show only the top two courses using LIMIT.:
SELECT * FROM courses LIMIT 2

===============================================================================================

9)Data Control Language (DCL):

LAB 1:

 1: Create two new users user1 and user2 and grant user1 permission to SELECT from the courses table.
	
	1. Create two users
CREATE USER 'user1'@'localhost' IDENTIFIED BY 'password1';
CREATE USER 'user2'@'localhost' IDENTIFIED BY 'password2';

	2. Grant SELECT permission to user1 on courses table
GRANT SELECT ON university_db.courses TO 'user1'@'localhost';

LAB 2:

 2: Revoke the INSERT permission from user1 and give it to user2.

	1.Revoke INSERT from user1
REVOKE INSERT ON university_db.courses FROM 'user1'@'localhost';

	 2.Grant INSERT to user2
GRANT INSERT ON university_db.courses TO 'user2'@'localhost';

	3. Apply privilege changes
FLUSH PRIVILEGES;

===============================================================================================

10)Transaction Control Language (TCL):

LAB 1:

1: Insert a few rows into the courses table and use COMMIT to save the changes.
	
	1.Start a transaction
START TRANSACTION;

	2. Insert some rows
INSERT INTO university_db.courses (course_id, course_name, credits) VALUES (101, 'Mathematics', 3);
INSERT INTO university_db.courses (course_id, course_name, credits) VALUES (102, 'Physics', 4);

	3.Save changes permanently
COMMIT;

LAB 2:

2: Insert additional rows, then use ROLLBACK to undo the last insert operation.

	1.Start another transaction
START TRANSACTION;

	2.Insert more rows
INSERT INTO university_db.courses (course_id, course_name, credits) VALUES (103, 'Chemistry', 4);
INSERT INTO university_db.courses (course_id, course_name, credits) VALUES (104, 'Biology', 3);

	3. Undo these insertions
ROLLBACK;

LAB 3:

3: Create a SAVEPOINT before updating the courses table, and use it to roll back specific changes.

	1.Start transaction
START TRANSACTION;

	2.Insert a row
INSERT INTO university_db.courses (course_id, course_name, credits) VALUES (105, 'Computer Science', 4);

	3.Create a savepoint
SAVEPOINT before_update;

	4.Update a course
UPDATE university_db.courses SET credits = 5 WHERE course_id = 101;

	5.Rollback to savepoint (undo the update but keep the insert)
ROLLBACK TO before_update;

	6. Commit the insert (Computer Science) only
COMMIT;

===============================================================================================

11)SQL Joins:

LAB 1:

 1: Create two tables: departments and employees. Perform an INNER JOIN to display employees along with their respective departments.

1.CREATE TABLE departments(dept_id int PRIMARY KEY AUTO_INCREMENT,dept_name varchar(50))

2.CREATE TABLE employees(emp_id int PRIMARY KEY AUTO_INCREMENT,emp_name varchar(50), dept_id int)

3.ALTER table employees ADD INDEX(dept_id)

4.insert into departments:
INSERT INTO departments(dept_name) VALUES('HR'),('IT'),('FINANCE')

5.insert into employees:
INSERT INTO employees(emp_id,emp_name,dept_id) VALUES(101,'Hensi',2),(102,'Mahek',1),(103,'Jitendra',2),(104,'Sonal',3),(105,'Manoj',1)

6.inner join:
SELECT * FROM employees e JOIN departments d ON e.dept_id = d.dept_id;

LAB 2:

2: Use a LEFT JOIN to show all departments, even those without employees:
SELECT * FROM departments d LEFT JOIN employees e ON d.dept_id = e.dept_id

===============================================================================================

12)SQL Group By:

LAB 1:

1: Group employees by department and count the number of employees in each
department using GROUP BY.

SELECT dept_id,COUNT(emp_id) AS total_emp FROM employees GROUP BY dept_id

LAB 2:

2: Use the AVG aggregate function to find the average salary of employees in each
department.

	1.add column salary:
ALTER TABLE employees ADD COLUMN salary int

	2.insert salary:
UPDATE employees SET salary = 10000 WHERE emp_id = 101;
UPDATE employees SET salary = 50000 WHERE emp_id = 102;
UPDATE employees SET salary = 90000 WHERE emp_id = 103;
UPDATE employees SET salary = 100000 WHERE emp_id = 104;
UPDATE employees SET salary = 6000 WHERE emp_id = 105;

	3.average salary:
SELECT dept_id,AVG(salary) AS avg_s FROM employees GROUP by dept_id

===============================================================================================

13)SQL Stored Procedure:

LAB 1:

1: Write a stored procedure to retrieve all employees from the employees table based
on department.

DELIMITER $$

CREATE PROCEDURE GetEmployeesByDepartment(IN dept INT)
BEGIN
    SELECT * 
    FROM employees 
    WHERE dept_id = dept;
END $$

DELIMITER ;

LAB 2:

2: Write a stored procedure that accepts course_id as input and returns the course
details.

DELIMITER //

CREATE PROCEDURE GetCourseById(IN cid INT)
BEGIN
    SELECT * 
    FROM courses 
    WHERE course_id = cid;
END //

DELIMITER ;

===============================================================================================

14)SQL View:

LAB 1:

1: Create a view to show all employees along with their department names.

CREATE VIEW emp_dept_view AS SELECT e.emp_id , e.emp_name,d.dept_name, e.salary FROM  employees e JOIN departments d on e.dept_id= d.dept_id

LAB 2:

 2: Modify the view to exclude employees whose salaries are below $50,000.
CREATE OR REPLACE VIEW emp_dept_view AS SELECT e.emp_id , e.emp_name,d.dept_name, e.salary FROM  employees e JOIN departments d on e.dept_id= d.dept_id WHERE e.salary < 50000

===============================================================================================

15)SQL Triggers:

LAB 1:

1: Create a trigger to automatically log changes to the employees table when a new
employee is added.

	1.create a table employee_log

CREATE TABLE employee_log (
    log_id INT AUTO_INCREMENT PRIMARY KEY,
    emp_id INT,
    emp_name VARCHAR(100),
    action_type VARCHAR(20),
    action_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

	2.create a trigger:

DELIMITER $$

CREATE TRIGGER after_employee_insert AFTER INSERT ON employees FOR EACH ROW
BEGIN
    INSERT INTO employee_log (emp_id, emp_name, action_type)
    VALUES (NEW.emp_id, NEW.emp_name, 'INSERT');
END $$

DELIMITER ;

	3.insert on employee and data add to the employee_log

LAB 2:

2: Create a trigger to update the last_modified timestamp whenever an employee
record is updated.

	1.add column last_modified in employees table:

ALTER TABLE employees
ADD COLUMN last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP
ON UPDATE CURRENT_TIMESTAMP;

	2. Create a Trigger to Update last_modified:

DELIMITER $$

CREATE TRIGGER before_employee_update
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
    SET NEW.last_modified = CURRENT_TIMESTAMP;
END $$

DELIMITER ;

UPDATE employees
SET emp_name = 'mahi'
WHERE emp_id = 102;
(The last_modified column for that row will be automatically updated to the current timestamp.)

===============================================================================================

16) Introduction to PL/SQL:

LAB 1:

1: Write a PL/SQL block to print the total number of employees from the employees table.

DELIMITER $$

CREATE PROCEDURE total_emp()
BEGIN
  DECLARE total_employees INT;

  SELECT COUNT(emp_id) AS total_employees FROM employees;

 
END$$

DELIMITER ;

LAB 2:

2: Create a PL/SQL block that calculates the total sales from an orders table.

DELIMITER $$

CREATE PROCEDURE total_sale()
BEGIN

  SELECT SUM(Quantity) AS total_sale FROM orderdetails;

END$$

DELIMITER ;
===============================================================================================

17)PL/SQL Control Structures:

LAB 1:

1: Write a PL/SQL block using an IF-THEN condition to check the department of an employee.

DELIMITER $$

CREATE PROCEDURE CheckDepartment(IN p_emp_id INT)
BEGIN
  DECLARE v_dept_id INT;

  -- Get the department ID of the given employee
  SELECT dept_id INTO v_dept_id
  FROM employees
  WHERE emp_id = p_emp_id;

  -- Check department and print message
  IF v_dept_id = 1 THEN
    SELECT 'Employee is in HR Department.' AS Message;
  ELSEIF v_dept_id = 2 THEN
    SELECT 'Employee is in IT Department.' AS Message;
  ELSEIF v_dept_id = 3 THEN
    SELECT 'Employee is in Finance Department.' AS Message;
  ELSE
    SELECT 'Employee is in another Department.' AS Message;
  END IF;
END$$

DELIMITER ;

LAB 2:
	
2: Use a FOR LOOP to iterate through employee records and display their names.

DELIMITER $$

CREATE PROCEDURE ShowEmployeeNames()
BEGIN
  DECLARE emp_name_var VARCHAR(100);
  DECLARE done INT DEFAULT 0;

  -- Declare a cursor
  DECLARE emp_cursor CURSOR FOR SELECT emp_name FROM employees;

  -- Declare a continue handler to exit the loop
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  -- Open the cursor
  OPEN emp_cursor;

  read_loop: LOOP
    FETCH emp_cursor INTO emp_name_var;
    IF done THEN
      LEAVE read_loop;
    END IF;
    SELECT emp_name_var AS 'Employee Name';
  END LOOP;

  -- Close the cursor
  CLOSE emp_cursor;
END$$

DELIMITER ;

===============================================================================================

18)SQL Cursors:

LAB 1:

1: Write a PL/SQL block using an explicit cursor to retrieve and display employee details.

DELIMITER $$

CREATE PROCEDURE show_employees()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE v_id INT;
  DECLARE v_name VARCHAR(100);
  DECLARE v_dept INT;
  DECLARE v_salary DECIMAL(10,2);

  DECLARE emp_cursor CURSOR FOR
    SELECT emp_id, emp_name, dept_id, salary FROM employees;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  OPEN emp_cursor;

  read_loop: LOOP
    FETCH emp_cursor INTO v_id, v_name, v_dept, v_salary;
    IF done THEN
      LEAVE read_loop;
    END IF;

    -- Show employee details
    SELECT v_id AS Emp_ID, 
           v_name AS Name, 
           v_dept AS Dept_ID, 
           v_salary AS Salary;

  END LOOP;

  CLOSE emp_cursor;
END $$

DELIMITER ;

LAB 2:

2: Create a cursor to retrieve all courses and display them one by one.

DELIMITER $$

CREATE PROCEDURE show_courses()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE v_id INT;
  DECLARE v_name VARCHAR(100);
  DECLARE v_duration VARCHAR(50);

  -- Cursor to get all courses
  DECLARE course_cursor CURSOR FOR
    SELECT course_id, course_name, course_duration FROM courses;

  -- Handler for end of data
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  -- Open the cursor
  OPEN course_cursor;

  read_loop: LOOP
    FETCH course_cursor INTO v_id, v_name, v_duration;
    
    IF done THEN
      LEAVE read_loop;
    END IF;

    -- Show course details
    SELECT v_id AS Course_ID, 
           v_name AS Course_Name, 
           v_duration AS Duration;

  END LOOP;

  -- Close the cursor
  CLOSE course_cursor;
END $$

DELIMITER ;

===============================================================================================

19)Rollback and Commit Savepoint:

LAB 1:

1: Perform a transaction where you create a savepoint, insert records, then rollback to the savepoint.

--1.Assume we have a table named students with fields:
student_id INT AUTO_INCREMENT PRIMARY KEY,
student_name VARCHAR(100)

--2.Step-by-Step Transaction Example:
-- Start the transaction
START TRANSACTION;

-- Insert first student
INSERT INTO students (student_name) VALUES ('Kinjal');

-- Create a savepoint
SAVEPOINT sp1;

-- Insert more students
INSERT INTO students (student_name) VALUES ('Prasant');
INSERT INTO students (student_name) VALUES ('Pravin');

-- Rollback to savepoint (Prasant & Pravin will be removed, Kinjal remains)
ROLLBACK TO SAVEPOINT sp1;

-- Commit the transaction (only John is saved)
COMMIT;

--3.Check Result:
SELECT * FROM students;

LAB 2:

2: Commit part of a transaction after using a savepoint and then rollback the remaining changes.

-- Start the transaction
START TRANSACTION;

-- Step 1: Insert first student
INSERT INTO students (student_name) VALUES ('Kinjal');

-- Step 2: Create savepoint A
SAVEPOINT sp1;

-- Step 3: Insert second student
INSERT INTO students (student_name) VALUES ('Prasant');

-- Step 4: Release savepoint and commit this part
RELEASE SAVEPOINT sp1;
COMMIT;

-- Step 5: Start another transaction (continue)
START TRANSACTION;

-- Step 6: Insert third student
INSERT INTO students (student_name) VALUES ('pravin');

-- Step 7: Rollback this last insert
ROLLBACK;

-- step 8: Final commit (nothing new to commit)
COMMIT;

===============================================================================================



















